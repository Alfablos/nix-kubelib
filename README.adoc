= Kubelib: Nix utilities for Kubernetes

Inspired by https://github.com/farcaller/nix-kube-generators.

A set of tools to handle Kubernetes related resources.

WARNING: this library makes use of https://github.com/mikefarah/yq[github:mikefarah/yq], *NOT* https://github.com/kislyuk/yq[github:kislyuk/yq]! Keep it in mind while troubleshooting.

Many are convenience wrappers around others.


== Lib
The library has 2 main focuses: one is handling YAML, JSON and Nix conversions, while the other is managing Helm Charts.

=== YAML Lib
.`-`: self type, `builtin`: builtin in Nix
[cols="1,1,1,1,1,1,1"]
|===
| Input type | YAML | JSON | JSON file | Multiple JSON files | Nix | Nix List

| YAML content (1 object) | - |  `yamlToJson` |  `yamlToJsonFile` |  `yamlToMultiJsonFiles` |  `yamlToNix` |  `yamlToNix`

| YAML content (multiple objects) | - |  `yamlToJson` |  `yamlToJsonFile`|  `yamlToMultiJsonFiles` |  `yamlToNix` |  `yamlToNixList`

| YAML file (single object) | - |  `yamlFileToJson` |   `yamlFileToJsonFile` |  `yamlFileToMultiJsonFiles` |  `yamlFileToNix` |  `yamlFileToNixList`

| YAML file (multiple objects) | - |  `yamlFileToJson` |  `yamlToJsonFile`|  `yamlToMultiJsonFiles` |  `yamlFileToNix` |  `yamlFileToNixList`

| Nix |  `nixToYaml` | _builtin_ | _builtin_ | *no* | - | -

| JSON content |  `jsonToYamlFile` (YAML file) | - | - | *no* | _builtin_ | _builtin_

| JSON file |  `jsonFileToYamlFile` (YAML file) | - | - | *no* | _builtin_ | _builtin_

|===

.Additional utils
[cols="1,4"]
|===

| `toList` | Turns a Nix list into the Nix equivalent of a Kubernetes resource list (kind: List).

| `keyValFromJsonManifest` |   Takes a JSON kubernetes manifests and builds a key-value pair
from the manifest. Also deals with lists.

- The VALUE is the content of the file itself

- The KEY is the string interpolation of resource name, resource kind
and resource namespace. In case of a non-namespaced resource, the kind is repeated.

| `keyValFromJsonManifestFiles` | Sane as keyValFromJsonManifest but allows multiple paths as input.

|===


=== Helm lib

* *downloadHelmChart*
* *buildHelmChart*


== Lib Functions

=== `toList`
Turns a Nix list into the Nix equivalent of a Kubernetes resource list (kind: List)

[source,haskell]
----
toList :: [a] -> kubernetes::List a
----

.example
[%collapsible]
====
[source,nix]
----
toList [ { a = "some"; b = "data"; } { a = "some"; b = "other"; c = "data"; } ]

{
  apiVersion = "v1";
  items = [
    {
      a = "some";
      b = "data";
    }
    {
      a = "some";
      b = "other";
      c = "data";
    }
  ];
  kind = "List";
}
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  toList = items: {
    apiVersion = "v1";
    kind = "List";
    inherit items;
  };
}
----
====


=== `keyValFromJsonManifest`
Takes a JSON kubernetes manifest `content` and builds a key-value pair from the manifest.

- The *VALUE* is the content of the file itself

- The *KEY* is the string interpolation of resource name, resource kind and resource namespace. In case of a non-namespaced resource, the kind is repeated

[source,haskell]
----
keyValFromJsonManifest: a -> Attrset
keyValFromJsonManifest: [a] -> [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
keyValFromJsonManifest (builtins.readFile ./server-cert.json)       # Single

{ mypp-serverauth-certificate-myapp = "{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"metadata\":{\"name\":\"mypp-serverauth\",\"namespace\":\"myapp\"},\"spec\":{\"dnsNames\":[\"myapp.mydoma
in.com\"],\"issuerRef\":{\"kind\":\"ClusterIssuer\",\"name\":\"letsencrypt-dns\"},\"secretName\":\"myapp-server-tls\",\"usages\":[\"server auth\"]}}"; }

keyValFromJsonManifest (yamlToJson { yamlContent = builtins.readFile ./services.yml; }    # Multi)

[
  { myapp-service-myapp = "{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"labels\":{\"app\":\"myapp\",\"component\":\"main\"},\"name\":\"myapp\",\"namespace\":\"myapp\"},\"spec\":{\"ports\":[{\"name\":\"http\",\"port\":80,\"protocol\":\"TCP\",\"targetPort\":\"http\"},{\"name\":\"https\",\"port\":443,\"protocol\":\"TCP\",\"targetPort\":\"https\"}],\"selector\":{\"app\":\"myapp\",\"components\":\"main\"}}}"; }
  { myapp-jobscheduler-service-myapp = "{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"labels\":{\"app\":\"myapp\",\"component\":\"jobscheduler\"},\"name\":\"myapp-jobscheduler\",\"namespace\":\"myapp\"},\"spec\":{\"ports\":[{\"name\":\"http\",\"port\":3000,\"protocol\":\"TCP\",\"targetPort\":\"http\"}],\"selector\":{\"app\":\"myapp\",\"component\":\"jobscheduler\"}}}"; }
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  keyValFromJsonManifest =
    input:
    let
      nixData = fromJSON input;
      process = c:
        let
          name = c.metadata.name;
          kind = lib.strings.toLower c.kind;
          third = c.metadata.namespace or kind;
        in
        {
          "${name}-${kind}-${third}" = toJSON c;
        };

      f =
        nixContent: if isList nixContent then map (cont: process cont) nixContent else process nixContent;
    in
    f nixData;

}
----
====

=== `keyValFromJsonManifestFile`
Same as keyValFromJsonManifest but accespts a `path` instead of content.

[source,haskell]
----
keyValFromJsonManifestFile :: p -> Attrset || [Attrset]
----


.implementation
[%collapsible]
====
[source,nix]
----
{
  keyValFromJsonManifestFile = path: readPathAndThen path keyValFromJsonManifest;
}
----
====

=== `keyValFromJsonManifestFiles`
Same as keyValFromJsonManifestFile but deals with Lists of `paths`.

[source,haskell]
----
keyValFromJsonManifestFiles :: [p] -> [Attrset]
----


.implementation
[%collapsible]
====
[source,nix]
----
{
  keyValFromJsonManifestFiles =
    paths:
    let
      list = map (p: keyValFromJsonManifestFile p) paths;
    in
    lib.attrsets.mergeAttrsList list;
}
----
====

=== `yamlToJson`
Turns input YAML `content` into JSON.

[source,haskell]
----
yamlToJson :: Attrset{ yamlContent, outputType ? "array" } -> String
----

The input is an Attrset of:

* *yamlContent*: YAML content as string
* *outputType*, which only makes sense if you know the result will be a list:
** _array_ (default): simple JSON array. `[ {...},{...},... ]`
** _object_: JSON object with your data stored in the _items_ key. `{ "items": [ {...},{...},... ] }`


.example
[%collapsible]
====
[source,nix]
----
yamlToJson { yamlContent = builtins.readFile ./services.yml; }

"[\n  {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Service\",\n    \"metadata\": {\n      \"name\": \"m
yapp\",\n      \"namespace\": \"myapp\",\n      \"labels\": {\n        \"app\": \"myapp\",\n        \"component\": \"m
ain\"\n      }\n    },\n    \"spec\": {\n      \"ports\": [\n        {\n          \"name\": \"http\",\n          \"por
t\": 80,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"http\"\n        },\n        {\n          \"nam
e\": \"https\",\n          \"port\": 443,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"https\"\n
    }\n      ],\n      \"selector\": {\n        \"app\": \"myapp\",\n        \"components\": \"main\"\n      }\n    }\
n  },\n  {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Service\",\n    \"metadata\": {\n      \"name\": \"myapp-jobs
cheduler\",\n      \"namespace\": \"myapp\",\n      \"labels\": {\n        \"app\": \"myapp\",\n        \"component\":
 \"jobscheduler\"\n      }\n    },\n    \"spec\": {\n      \"ports\": [\n        {\n          \"name\": \"http\",\n
       \"port\": 3000,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"http\"\n        }\n      ],\n
   \"selector\": {\n        \"app\": \"myapp\",\n        \"component\": \"jobscheduler\"\n      }\n    }\n  }\n]\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToJson =
    {
      yamlContent,
      outputType ? "array",
    }@args:
    let
      f = kallPackage args yamlToJsonFile { };
    in
    readFile f;
}
----
====

=== `yamlToJsonFile`
Similar to yamlToJson but turns input YAML `content` into a _single_ JSON file [.underline]#*in the store*#.

[source,haskell]
----
yamlToJson :: Attrset{ path, outputType ? "array" } -> Derivation
----

The input is an Attrset of:

* *yamlContent*: YAML content as string
* *outputType*, which only makes sense if you know the result will be a list:
** _array_ (default): simple JSON array. `[ {...},{...},... ]`
** _object_: JSON object with your data stored in the _items_ key. `{ "items": [ {...},{...},... ] }`

.example
[%collapsible]
====
[source,nix]
----


builtins.readFile yamlToJsonFile { yamlContent = builtins.readFile ./services.yml; outputType = "object"; }        # Singe it returns a derivation

"{\n  \"items\": [\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Service\",\n      \"metadata\": {\n        \"name\": \"myapp\",\n        \"namespace\": \"myapp\",\n        \"labels\": {\n          \"app\": \"myapp\",\n          \"component\": \"main\"\n        }\n      },\n      \"spec\": {\n        \"ports\": [\n          {\n            \"name\": \"http\",\n            \"port\": 80,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"http\"\n          },\n          {\n            \"name\": \"https\",\n            \"port\": 443,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"https\"\n          }\n        ],\n        \"selector\": {\n          \"app\": \"myapp\",\n          \"components\": \"main\"\n        }\n      }\n    },\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Service\",\n      \"metadata\": {\n        \"name\": \"myapp-jobscheduler\",\n        \"namespace\": \"myapp\",\n        \"labels\": {\n          \"app\": \"myapp\",\n          \"component\": \"jobscheduler\"\n        }\n      },\n      \"spec\": {\n        \"ports\": [\n          {\n            \"name\": \"http\",\n            \"port\": 3000,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"http\"\n          }\n        ],\n        \"selector\": {\n          \"app\": \"myapp\",\n          \"component\": \"jobscheduler\"\n        }\n      }\n    }\n  ]\n}\n"

----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToJsonFile =
    {
      yamlContent,
      outputType ? "array",
    }:
    let
      jqReturnValue =
        if outputType == "array" then
          "."
        else if outputType == "object" then
          "{ items:. }"
        else
          throw "Unknown output type ${outputType}";

      jqCommand = "${pkgs.jq}/bin/jq -n '[inputs] | if length == 1 then .[0] else ${jqReturnValue} end | .'";
    in
    pkgs.stdenv.mkDerivation {
      name = "yaml2jsonfile";
      inherit yamlContent;
      passAsFile = [ "yamlContent" ];
      phases = [ "installPhase" ];
      installPhase = "${pkgs.yq-go}/bin/yq $yamlContentPath -p yaml -o json | ${jqCommand} > $out";
    };

}
----
====


=== `yamlToMultiJsonFiles`
The purpose of this function is to automate the creation of a set of files compatible with the https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/addon-manager/README.md[Kubernetes AddonManager] which is the https://github.com/NixOS/nixpkgs/blob/046eee4ec50a7b86148b056d6ddb44c4fc9a6a15/nixos/modules/services/cluster/kubernetes/addon-manager.nix#L27[default way of installing addons if you're running Kubernetes bare metal on NixOS].

It turns some YAML content describing ONE OR MORE Kubernetes resources into as many JSON manifests as resources described. The return value is the [.underline]#*store path*# containing built files.


[source,haskell]
----
yamlToMultiJsonFiles :: Attrset{ yamlContent, yqExpression ? null } -> Derivation
----

yamlToMultiJsonFiles, by default, uses the following https://github.com/mikefarah/yq[yq] expression: +
`.metadata.name + "-" + (.kind | downcase) + "-" + (.metadata.namespace // (.kind | downcase))`

Files are created as follows:

* The *filename* is, by default, the string interpolation of resource name, resource kind and resource namespace. In case of a non-namespaced resource, the kind is repeated.
 * The *value* is the content of the file itself

The input is an Attrset of:

* *yamlContent*: YAML content as string
* *yqExpression*: yqExpression override in case you want a different naming.


.example
[%collapsible]
====
[source,nix]
----
builtins.attrNames (builtins.readDir ( yamlToMultiJsonFiles { yamlContent = builtins.readFile ./services.yml; } ))

[
  "myapp-jobscheduler-service-myapp.json"
  "myapp-service-myapp.json"
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToMultiJsonFiles =
    {
      yamlContent,
      yqExpression ? null,
    }:
    let
      yqExpr =
        if yqExpression == null then
          ".metadata.name + \"-\" + (.kind | downcase) + \"-\" + (.metadata.namespace // (.kind | downcase))"
        else
          yqExpression;
    in
    pkgs.stdenv.mkDerivation {
      name = "yaml2multijsonfile";
      inherit yamlContent;
      passAsFile = [ "yamlContent" ];
      phases = [ "buildPhase" ];
      buildPhase = ''
        mkdir $out
        cd $out
        ${pkgs.yq-go}/bin/yq -p yaml -o json -s '${yqExpr}' $yamlContentPath
      '';
    };
}
----
====

=== `yamlToMultiJsonFilePaths`
It turns some YAML content describing ONE OR MORE Kubernetes resources into as many JSON manifests as resources described. The return value is a list of [.underline]#*store path*# containing built files.

It uses yamlToMultiJsonFiles under the hood, inputs and logic are the same.

[source,haskell]
----
yamlToMultiJsonFiles :: Attrset{ yamlContent, yqExpression ? null } -> [String]
----

.example
[%collapsible]
====
[source,nix]
----
yamlToMultiJsonFilePaths { yamlContent = builtins.readFile ./services.yml; }

[
  "/nix/store/7c6px9in1i05bl3r2j9jym564vhhpzs0-yaml2multijsonfile/myapp-jobscheduler-service-myapp.json"
  "/nix/store/7c6px9in1i05bl3r2j9jym564vhhpzs0-yaml2multijsonfile/myapp-service-myapp.json"
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToMultiJsonFilePaths =
    {
      yamlContent,
      yqExpression ? null,
    }@args:
    getGeneratedFiles (yamlToMultiJsonFiles {
      inherit yamlContent yqExpression;
    });

}
----
====


=== `yamlToNix`
Loads parses YAML definitions into Nix language. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlToNix :: String -> Attrset / [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
yamlToNix (builtins.readFile ./server-cert.yml)

{
  apiVersion = "cert-manager.io/v1";
  kind = "Certificate";
  metadata = {
    name = "mypp-serverauth";
    namespace = "myapp";
  };
  spec = {
    dnsNames = [ "myapp.mydomain.com" ];
    issuerRef = {
      kind = "ClusterIssuer";
      name = "letsencrypt-dns";
    };
    secretName = "myapp-server-tls";
    usages = [ "server auth" ];
  };
}


yamlToNix (builtins.readFile ./services.yml)

[
  {
    apiVersion = "v1";
    kind = "Service";
    metadata = {
      labels = {
        app = "myapp";
        component = "main";
      };
      name = "myapp";
      namespace = "myapp";
    };
    spec = {
      ports = [
        {
          name = "http";
          port = 80;
          protocol = "TCP";
          targetPort = "http";
        }
        {
          name = "https";
          port = 443;
          protocol = "TCP";
          targetPort = "https";
        }
      ];
      selector = {
        app = "myapp";
        components = "main";
      };
    };
  }
  {
    apiVersion = "v1";
    kind = "Service";
    metadata = {
      labels = {
        app = "myapp";
        component = "jobscheduler";
      };
      name = "myapp-jobscheduler";
      namespace = "myapp";
    };
    spec = {
      ports = [
        {
          name = "http";
          port = 3000;
          protocol = "TCP";
          targetPort = "http";
        }
      ];
      selector = {
        app = "myapp";
        component = "jobscheduler";
      };
    };
  }
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToNix =
    yamlContent:
    fromJSON (yamlToJson {
      inherit yamlContent;
    });
}
----
====



=== `yamlToNixList`
Same as yamlToNix but forces the output to be a List. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlToNix :: String -> [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
yamlToNixList (builtins.readFile ./server-cert.yml)

[
  {
    apiVersion = "cert-manager.io/v1";
    kind = "Certificate";
    metadata = {
      name = "mypp-serverauth";
      namespace = "myapp";
    };
    spec = {
      dnsNames = [ "myapp.mydomain.com" ];
      issuerRef = {
        kind = "ClusterIssuer";
        name = "letsencrypt-dns";
      };
      secretName = "myapp-server-tls";
      usages = [ "server auth" ];
    };
  }
]
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToNixList =
    yamlContent:
    let
      fileAbsPaths = yamlToMultiJsonFilePaths { inherit yamlContent; };
    in
    map (path: readPathAndThen path fromJSON) fileAbsPaths;
}
----
====


=== `nixToYaml`
Converts Nix code to YAML string.  It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
nixToYaml :: Attrset -> String
----

.example
[%collapsible]
====
[source,nix]
----
builtins.readFile (nixToYaml { a = 1; b = 2; c = 3; })
"a: 1\nb: 2\nc: 3\n"

builtins.readFile (nixToYaml [{ a = 1;} { b = 2;} {c = 3;}])
"- a: 1\n- b: 2\n- c: 3\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  nixToYaml =
    attrs:
    let
      jsonContent = toJSON attrs;
    in
    pkgs.stdenv.mkDerivation {
      inherit jsonContent;
      name = "nixtoYaml";
      passAsFile = [ "jsonContent" ];
      phases = [ "buildPhase" ];
      buildPhase = "${pkgs.yq-go}/bin/yq -p json -o yaml $jsonContentPath > $out";
    };
}
----
====


=== `jsonToYaml`
Converts JSON content to YAML. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
jsonToYaml :: Attrset { jsonContent, topLevelKey ? null } -> String
----

The input is an Attrset of:

* *jsonContent*: JSON string data.
* *topLevelKey*: by default a JSON array is converted to a bare YAML array. This allows you to turn it into an object specifying the key the array should be put under. It's *ineffective if the content is not a list*.

.example
[%collapsible]
====
[source,nix]
----
jsonToYaml { jsonContent = builtins.readFile ./services.json; topLevelKey = "services"; }

"services:\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp\n      namespace: myapp\n      labels:\n        app: myapp\n        component: main\n    spec:\n      ports:\n        - name: http\n          port: 80\n          protocol: TCP\n          targetPort: http\n        - name: https\n          port: 443\n          protocol: TCP\n          targetPort: https\n      selector:\n        app: myapp\n        components: main\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp-jobscheduler\n      namespace: myapp\n      labels:\n        app: myapp\n        component: jobscheduler\n    spec:\n      ports:\n        - name: http\n          port: 3000\n          protocol: TCP\n          targetPort: http\n      selector:\n        app: myapp\n        component: jobscheduler\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  jsonToYaml =
    {
      jsonContent,
      topLevelKey ? null
    }@args:
    readFile ( kallPackage args jsonToYamlFile { } );
}
----
====



=== `jsonToYamlFile`
Same as jsonToYaml but stores the YAML content in a file.  It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
jsonToYamlFile :: Attrset { jsonContent, topLevelKey ? null } -> Derivation
----

.example
[%collapsible]
====
[source,nix]
----
builtins.readFile (jsonToYamlFile { jsonContent = builtins.readFile ./server-cert.json; topLevelKey = "services";})

----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  jsonToYamlFile =
    {
      jsonContent,
      topLevelKey ? null,
    }:
    pkgs.stdenv.mkDerivation rec {
      name = "json2yaml";
      inherit jsonContent topLevelKey;
      passAsFile = [ "jsonContent" ];
      phases = [ "installPhase" ];
      yqTransform = if topLevelKey != null && jsonIsList jsonContent then "--expression '{ \"${topLevelKey}\":. }'" else "";
      installPhase = "${pkgs.yq-go}/bin/yq $jsonContentPath -p json -o yaml ${yqTransform} > $out";
    };
}
----
====


=== `jsonFileToYamlFile`
Same as jsonToYamlFile but automatically reads from a path. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
jsonFileToYamlFile :: Attrset { path, topLevelKey ? null } -> Derivation
----

.example
[%collapsible]
====
[source,nix]
----
builtins.readFile (jsonFileToYamlFile { path = ./services.json; topLevelKey = "services"; })
"services:\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp\n      namespace: myapp\n      labels:\n        app: myapp\n        component: main\n    spec:\n      ports:\n        - name: http\n          port: 80\n          protocol: TCP\n          targetPort: http\n        - name: https\n          port: 443\n          protocol: TCP\n          targetPort: https\n      selector:\n        app: myapp\n        components: main\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp-jobscheduler\n      namespace: myapp\n      labels:\n        app: myapp\n        component: jobscheduler\n    spec:\n      ports:\n        - name: http\n          port: 3000\n          protocol: TCP\n          targetPort: http\n      selector:\n        app: myapp\n        component: jobscheduler\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  jsonFileToYamlFile =
    { path, topLevelKey ? null }@args:
    kallPackage args jsonToYamlFile { jsonContent = builtins.readFile path; };
}
----
====





=== `yamlFileToJson`
Same as yamlToJson but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToJson :: Attrset { path, outputType ? "array" } -> String
----

.example
[%collapsible]
====
[source,nix]
----
yamlFileToJson { path = ./services.yml; outputType = "object"; }

"{\n  \"items\": [\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Service\",\n      \"metadata\": {\n        \"name\": \"myapp\",\n        \"namespace\": \"myapp\",\n        \"labels\": {\n          \"app\": \"myapp\",\n          \"component\": \"main\"\n        }\n      },\n      \"spec\": {\n        \"ports\": [\n          {\n            \"name\": \"http\",\n            \"port\": 80,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"http\"\n          },\n          {\n            \"name\": \"https\",\n            \"port\": 443,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"https\"\n          }\n        ],\n        \"selector\": {\n          \"app\": \"myapp\",\n          \"components\": \"main\"\n        }\n      }\n    },\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Service\",\n      \"metadata\": {\n        \"name\": \"myapp-jobscheduler\",\n        \"namespace\": \"myapp\",\n        \"labels\": {\n          \"app\": \"myapp\",\n          \"component\": \"jobscheduler\"\n        }\n      },\n      \"spec\": {\n        \"ports\": [\n          {\n            \"name\": \"http\",\n            \"port\": 3000,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"http\"\n          }\n        ],\n        \"selector\": {\n          \"app\": \"myapp\",\n          \"component\": \"jobscheduler\"\n        }\n      }\n    }\n  ]\n}\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToJson =
    {
      path,
      outputType ? "array",
    }@args:
    callWithYamlContent args yamlToJson;
}
----
====

=== `yamlFileToJsonFile`
Same as yamlToJsonFile but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToJsonFile :: Attrset { path, outputType ? "array" } -> Derivation
----

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToJsonFile =
    {
      path,
      outputType ? "array",
    }@args:
    callWithYamlContent args yamlToJsonFile;
}
----
====



=== `yamlFileToMultiJsonFiles`
Same as yamlToMultiJsonFiles but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToMultiJsonFiles :: Attrset { path, yqExpression ? null } -> Derivation
----

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToMultiJsonFiles =
    {
      path,
      yqExpression ? null,
    }@args:
    callWithYamlContent args yamlToMultiJsonFiles;
}
----
====


=== `yamlFileToNix`
Same as yamlToNix but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToNix :: String -> Attrset / [Attrset]
----

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToNix = path: readPathAndThen path yamlToNix;
}
----
====



=== `yamlFileToNixList`
Same as yamToNixList but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToNix :: String -> [Attrset]
----

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToNixList = path: readPathAndThen path yamlToNixList;
}
----
====
