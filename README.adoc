= Kubelib: Nix utilities for Kubernetes

Inspired by https://github.com/farcaller/nix-kube-generators[farcaller/nix-kube-generators].

A set of tools to handle Kubernetes related resources and Nix, JSON and YAML conversions.

WARNING: this library makes use of https://github.com/mikefarah/yq[mikefarah/yq], *NOT* https://github.com/kislyuk/yq[kislyuk/yq]! Keep it in mind while troubleshooting.

CAUTION: Many functions will [.underline]#*copy data to the Nix store*#

Some functions are convenience wrappers around others, so you can keep the code cleaner.


== Lib
The library has 2 main focuses: one is handling YAML, JSON and Nix conversions, while the other is managing Helm Charts.

=== YAML Lib
.`-`: self type, `builtin`: builtin in Nix
[cols="1,1,1,1,1,1,1"]
|===
| Input type | YAML | JSON | JSON file | Multiple JSON files | Nix | Nix List

| YAML content (1 object) | - | `yamlToJson` | `yamlToJsonFile` | `yamlToMultiJsonFiles` | `yamlToNix` | `yamlToNix`

| YAML content (multiple objects) | - | `yamlToJson` | `yamlToJsonFile` | `yamlToMultiJsonFiles` | `yamlToNix` | `yamlToNixList`

| YAML file (single object) | - | `yamlToJson` | `yamlToJsonFile` | `yamlFileToMultiJsonFiles` | `yamlFileToNix` | `yamlFileToNixList`

| YAML file (multiple objects) | - | `yamlToJson` | `yamlToJsonFile`| `yamlToMultiJsonFiles` | `yamlFileToNix` | `yamlFileToNixList`

| Nix | `nixToYaml` | _builtin_ | _builtin_ | *no* | - | -

| JSON content | `jsonToYaml` `jsonToYamlFile` | - | - | *no* | _builtin_ | _builtin_

| JSON file | `jsonFileToYamlFile` | - | - | *no* | _builtin_ | _builtin_
|===

.Additional utils
[cols="1,4"]
|===
| `toList` | Turns a Nix list into the Nix equivalent of a Kubernetes resource list (kind: List).

| `keyValFromJsonManifest` |   Takes a JSON kubernetes manifests and builds a key-value pair
from the manifest. Also deals with lists.

- The VALUE is the content of the file itself

- The KEY is the string interpolation of resource name, resource kind
and resource namespace. In case of a non-namespaced resource, the kind is repeated.

| `keyValFromJsonManifestFiles` | Sane as keyValFromJsonManifest but allows multiple paths as input.

|===

[.underline]#*From YAML*# functions:

* <<_yamlfiletomultijsonfiles,`yamlFileToMultiJsonFiles`>>
* <<_yamlfiletonix,`yamlFileToNix`>>
* <<_yamlfiletonixlist,`yamlFileToNixList`>>
* <<yamlToJson,`yamlToJson`>>
* <<_yamltojsonfile,`yamlToJsonFile`>>
* <<_yamltomultijsonfilepaths,`yamlToMultiJsonFilePaths`>>
* <<_yamltomultijsonfiles,`yamlToMultiJsonFiles`>>
* <<_yamltonix,`yamlToNix`>>
* <<_yamltonixlist,`yamlToNixList`>>

[.underline]#*From JSON*# functions:

* <<_jsonfiletoyamlfile,`jsonFileToYamlFile`>>
* <<_jsontoyaml,`jsonToYaml`>>
* <<_jsontoyamlfile,`jsonToYamlFile`>>
* <<_keyvalfromjsonmanifest,`keyValFromJsonManifest`>>
* <<_keyvalfromjsonmanifestfile,`keyValFromJsonManifestFile`>>
* <<_keyvalfromjsonmanifestfiles,`keyValFromJsonManifestFiles`>>

[.underline]#*From Nix*# functions:

* <<_nixtoyaml,`nixToYaml`>>

[.underline]#*Others*#:

* <<_tolist,`toList`>>

[#wrapper]
=== Functions Signatures
A wrapper around many functions takes care of adding additional flexibility while calling them. +
For example you can call _yamlToJsonFile_ in several ways depending on what kind of input you have and how clean you want to keep your code while not needing additional control. Even the _source_ parameter can have multiple forms:

[source,haskell]
----
yamlToJsonFile :: Path => Derivation
yamlToJsonFile :: String => Derivation
yamlToJsonFile :: [ Path ] => [ Derivation ]
yamlToJsonFile :: [ String ] => [ Derivation ]
yamlToJsonFile :: Attrset { source, outputType ? null } => Derivation
yamlToJsonFile :: [ Attrset { source (Path), outputType ? null } ] => [ Derivation ]
yamlToJsonFile :: [ Attrset { source (String), outputType ? null } ++ Path ++ String ] => [ Derivation ]
----

For example these are all valid methods:

[source,nix]
----
yamlToJsonFile ./tests/server-cert.yml                          # path
yamlToJsonFile (builtins.readFile ./tests/server-cert.yml)      # string
yamlToJsonFile [ ./tests/server-cert.yml ./tests/services.yml ./another/path.nix ] # paths
yamlToJsonFile [ (builtins.readFile ./tests/server-cert.yml)  (builtins.readFile ./tests/services.yml) ]                                         # strings
yamlToJsonFile { source = ./tests/services.yml; outputType = "object"; }    # Attrset
yamlToJsonFile [ { source = ./tests/server-cert.yml; } { source = builtins.readFile ./tests/services.yml; } ]      # Attrsets
yamlToJsonFile [ { source = ./tests/services.yml; outputType = "object"; } ./tests/services.yml (builtins.readFile ./tests/server-cert.yml) ]   # mix
----

[.underline]#*Expect a list if you call the function with a list, no matter what its signature is!*#.

.Wrapper implementation
[%collapsible]
====
[source,nix]
----
rec {
  kallPackage =
    incomingArgs: f: overrides:
    let
      fArgs = functionArgs f;
      finalArgs = intersectAttrs fArgs incomingArgs // overrides; # Merge with overrides happens last
    in
    f finalArgs;

  # Allows to call a function in two ways:
  # - f /some/path or f (builtins.readFile /some/path) or f (drv)
  # - f { arg1 = "val1"; arg2 = "val2"; ... }
  # while calling the downstream function with a unified interface.
  resolveArgs = args: if isAttrs args then args else { source = args; };

  # Caller calls a function with args. Args can be { source, this, that, ... },
  # a path/string or a list of elements.
  # If a list is detected, each element is processed as follows:
  #   If a path is detected, the content is read before calling the downstream function.
  #   If args is Attrset then proceed, if not turn it into an Attrset with defaults.
  # If no list is passed process happens normally.
  # This allows to mix argument sources:
  # - yamlToJsonFile [ ./tests/services.yml (builtins.readFile ./tests/server-cert.yml) ]
  # - yamlToJsonFile [ { source = ./tests/services.yml; } { source = (builtins.readFile ./tests/server-cert.yml); } ]
  wrapF =
    args: f:
    let
      processUnit = as:
        let
          finalArgs = resolveArgs as;
          sourceIsPath = isPath finalArgs.source;
        in
        if sourceIsPath then
        kallPackage finalArgs f { source = readFile finalArgs.source; }
        else
        kallPackage finalArgs f { };
    in
    if isList args
    then map processUnit args
    else processUnit args;

}
----
====

=== Helm lib

* *downloadHelmChart*
* *buildHelmChart*


== Lib Functions

=== `toList`
Turns a Nix list into the Nix equivalent of a Kubernetes resource list (kind: List)

[source,haskell]
----
toList :: [a] -> kubernetes::List a
----

.example
[%collapsible]
====
[source,nix]
----
toList [ { a = "some"; b = "data"; } { a = "some"; b = "other"; c = "data"; } ]

{
  apiVersion = "v1";
  items = [
    {
      a = "some";
      b = "data";
    }
    {
      a = "some";
      b = "other";
      c = "data";
    }
  ];
  kind = "List";
}
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  toList = items: {
    apiVersion = "v1";
    kind = "List";
    inherit items;
  };
}
----
====

'''

=== `keyValFromJsonManifest`
Takes a JSON kubernetes manifest `content` and builds a key-value pair from the manifest.

- The *VALUE* is the content of the file itself

- The *KEY* is the string interpolation of resource name, resource kind and resource namespace. In case of a non-namespaced resource, the kind is repeated

[source,haskell]
----
keyValFromJsonManifest: a -> Attrset
keyValFromJsonManifest: [a] -> [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
keyValFromJsonManifest (builtins.readFile ./server-cert.json)       # Single

{ mypp-serverauth-certificate-myapp = "{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"metadata\":{\"name\":\"mypp-serverauth\",\"namespace\":\"myapp\"},\"spec\":{\"dnsNames\":[\"myapp.mydoma
in.com\"],\"issuerRef\":{\"kind\":\"ClusterIssuer\",\"name\":\"letsencrypt-dns\"},\"secretName\":\"myapp-server-tls\",\"usages\":[\"server auth\"]}}"; }

keyValFromJsonManifest (yamlToJson { yamlContent = builtins.readFile ./services.yml; }    # Multi)

[
  { myapp-service-myapp = "{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"labels\":{\"app\":\"myapp\",\"component\":\"main\"},\"name\":\"myapp\",\"namespace\":\"myapp\"},\"spec\":{\"ports\":[{\"name\":\"http\",\"port\":80,\"protocol\":\"TCP\",\"targetPort\":\"http\"},{\"name\":\"https\",\"port\":443,\"protocol\":\"TCP\",\"targetPort\":\"https\"}],\"selector\":{\"app\":\"myapp\",\"components\":\"main\"}}}"; }
  { myapp-jobscheduler-service-myapp = "{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"labels\":{\"app\":\"myapp\",\"component\":\"jobscheduler\"},\"name\":\"myapp-jobscheduler\",\"namespace\":\"myapp\"},\"spec\":{\"ports\":[{\"name\":\"http\",\"port\":3000,\"protocol\":\"TCP\",\"targetPort\":\"http\"}],\"selector\":{\"app\":\"myapp\",\"component\":\"jobscheduler\"}}}"; }
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  keyValFromJsonManifest =
    input:
    let
      nixData = fromJSON input;
      process = c:
        let
          name = c.metadata.name;
          kind = lib.strings.toLower c.kind;
          third = c.metadata.namespace or kind;
        in
        {
          "${name}-${kind}-${third}" = toJSON c;
        };

      f =
        nixContent: if isList nixContent then map (cont: process cont) nixContent else process nixContent;
    in
    f nixData;

}
----
====

'''

=== `keyValFromJsonManifestFile`
Same as keyValFromJsonManifest but accespts a `path` instead of content.

[source,haskell]
----
keyValFromJsonManifestFile :: p -> Attrset / [Attrset]
----


.example
[%collapsible]
====
[source,nix]
----
keyValFromJsonManifestFile ./server-cert.json
{ mypp-serverauth-certificate-myapp = "{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"metadata\":{\"name\":\"mypp-serverauth\",\"namespace\":\"myapp\"},\"spec\":{\"dnsNames\":[\"myapp.mydomain.com\"],\"issuerRef\":{\"kind\":\"ClusterIssuer\",\"name\":\"letsencrypt-dns\"},\"secretName\":\"myapp-server-tls\",\"usages\":[\"server auth\"]}}"; }
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  keyValFromJsonManifestFile = path: readPathAndThen path keyValFromJsonManifest;
}
----
====

'''

=== `keyValFromJsonManifestFiles`
Same as keyValFromJsonManifestFile but deals with Lists of `paths`.+
It supports paths to files with multiple objects within.

[source,haskell]
----
keyValFromJsonManifestFiles :: [p] -> [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
keyValFromJsonManifestFiles [ ./server-cert.json ./services.json ]
{
  myapp-jobscheduler-service-myapp = "{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"labels\":{\"app\":\"myapp\",\"component\":\"jobscheduler\"},\"name\":\"myapp-jobscheduler\",\"namespace\":\"myapp\"},\"spec\":{\"ports\":[{\"name\":\"http\",\"port\":3000,\"protocol\":\"TCP\",\"targetPort\":\"http\"}],\"selector\":{\"app\":\"myapp\",\"component\":\"jobscheduler\"}}}";
  myapp-service-myapp = "{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"labels\":{\"app\":\"myapp\",\"component\":\"main\"},\"name\":\"myapp\",\"namespace\":\"myapp\"},\"spec\":{\"ports\":[{\"name\":\"http\",\"port\":80,\"protocol\":\"TCP\",\"targetPort\":\"http\"},{\"name\":\"https\",\"port\":443,\"protocol\":\"TCP\",\"targetPort\":\"https\"}],\"selector\":{\"app\":\"myapp\",\"components\":\"main\"}}}";
  mypp-serverauth-certificate-myapp = "{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"metadata\":{\"name\":\"mypp-serverauth\",\"namespace\":\"myapp\"},\"spec\":{\"dnsNames\":[\"myapp.mydomain.com\"],\"issuerRef\":{\"kind\":\"ClusterIssuer\",\"name\":\"letsencrypt-dns\"},\"secretName\":\"myapp-server-tls\",\"usages\":[\"server auth\"]}}";
}

----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  keyValFromJsonManifestFiles =
    paths:
    let
      list = map (p: keyValFromJsonManifestFile p) paths;
    in
    lib.attrsets.mergeAttrsList (lib.lists.flatten pathList);
}
----
====

'''
[#yamlToJson]
=== `yamlToJson`
<<wrapper,Wrapped>>. Turns input YAML into JSON.

[source,haskell]
----
yamlToJson :: wrapped -> String
----

The input is an Attrset of:

* *yamlContent*: YAML content as string
* *outputType*, which only makes sense if you know the result will be a list:
** _array_ (default): simple JSON array. `[ {...},{...},... ]`
** _object_: JSON object with your data stored in the _items_ key. `{ "items": [ {...},{...},... ] }`


.example
[%collapsible]
====
[source,nix]
----
yamlToJson { source = builtins.readFile ./tests/services.yml; }

"[\n  {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Service\",\n    \"metadata\": {\n      \"name\": \"m
yapp\",\n      \"namespace\": \"myapp\",\n      \"labels\": {\n        \"app\": \"myapp\",\n        \"component\": \"m
ain\"\n      }\n    },\n    \"spec\": {\n      \"ports\": [\n        {\n          \"name\": \"http\",\n          \"por
t\": 80,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"http\"\n        },\n        {\n          \"nam
e\": \"https\",\n          \"port\": 443,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"https\"\n
    }\n      ],\n      \"selector\": {\n        \"app\": \"myapp\",\n        \"components\": \"main\"\n      }\n    }\
n  },\n  {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Service\",\n    \"metadata\": {\n      \"name\": \"myapp-jobs
cheduler\",\n      \"namespace\": \"myapp\",\n      \"labels\": {\n        \"app\": \"myapp\",\n        \"component\":
 \"jobscheduler\"\n      }\n    },\n    \"spec\": {\n      \"ports\": [\n        {\n          \"name\": \"http\",\n
       \"port\": 3000,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"http\"\n        }\n      ],\n
   \"selector\": {\n        \"app\": \"myapp\",\n        \"component\": \"jobscheduler\"\n      }\n    }\n  }\n]\n"

yamlToJson { source = builtins.readFile ./tests/services.yml; }

"[\n  {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Service\",\n    \"metadata\": {\n      \"name\": \"m
yapp\",\n      \"namespace\": \"myapp\",\n      \"labels\": {\n        \"app\": \"myapp\",\n        \"component\": \"m
ain\"\n      }\n    },\n    \"spec\": {\n      \"ports\": [\n        {\n          \"name\": \"http\",\n          \"por
t\": 80,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"http\"\n        },\n        {\n          \"nam
e\": \"https\",\n          \"port\": 443,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"https\"\n
    }\n      ],\n      \"selector\": {\n        \"app\": \"myapp\",\n        \"components\": \"main\"\n      }\n    }\
n  },\n  {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Service\",\n    \"metadata\": {\n      \"name\": \"myapp-jobs
cheduler\",\n      \"namespace\": \"myapp\",\n      \"labels\": {\n        \"app\": \"myapp\",\n        \"component\":
 \"jobscheduler\"\n      }\n    },\n    \"spec\": {\n      \"ports\": [\n        {\n          \"name\": \"http\",\n
       \"port\": 3000,\n          \"protocol\": \"TCP\",\n          \"targetPort\": \"http\"\n        }\n      ],\n
   \"selector\": {\n        \"app\": \"myapp\",\n        \"component\": \"jobscheduler\"\n      }\n    }\n  }\n]\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  # Converts YAML content to JSON.
  yamlToJson =
    args:
    if isList args
    then
      let paths = map (a: wrapF a _yamlToJsonFile) args;
      in map builtins.readFile paths
    else readFile (wrapF args _yamlToJsonFile);
}
----
====

'''

=== `yamlToJsonFile`
Similar to yamlToJson but turns input YAML `content` into a _single_ JSON file [.underline]#*in the store*#.

[source,haskell]
----
yamlToJson :: Attrset { source , outputType ? "array" } -> Derivation
yamlToJson :: Path / String -> Derivation
----

The input is an Attrset of:

* *yamlContent*: YAML content as string
* *outputType*, which only makes sense if you know the result will be a list:
** _array_ (default): simple JSON array. `[ {...},{...},... ]`
** _object_: JSON object with your data stored in the _items_ key. `{ "items": [ {...},{...},... ] }`

.example
[%collapsible]
====
[source,nix]
----


builtins.readFile yamlToJsonFile { yamlContent = builtins.readFile ./services.yml; outputType = "object"; }        # Since it returns a derivation

"{\n  \"items\": [\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Service\",\n      \"metadata\": {\n        \"name\": \"myapp\",\n        \"namespace\": \"myapp\",\n        \"labels\": {\n          \"app\": \"myapp\",\n          \"component\": \"main\"\n        }\n      },\n      \"spec\": {\n        \"ports\": [\n          {\n            \"name\": \"http\",\n            \"port\": 80,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"http\"\n          },\n          {\n            \"name\": \"https\",\n            \"port\": 443,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"https\"\n          }\n        ],\n        \"selector\": {\n          \"app\": \"myapp\",\n          \"components\": \"main\"\n        }\n      }\n    },\n    {\n      \"apiVersion\": \"v1\",\n      \"kind\": \"Service\",\n      \"metadata\": {\n        \"name\": \"myapp-jobscheduler\",\n        \"namespace\": \"myapp\",\n        \"labels\": {\n          \"app\": \"myapp\",\n          \"component\": \"jobscheduler\"\n        }\n      },\n      \"spec\": {\n        \"ports\": [\n          {\n            \"name\": \"http\",\n            \"port\": 3000,\n            \"protocol\": \"TCP\",\n            \"targetPort\": \"http\"\n          }\n        ],\n        \"selector\": {\n          \"app\": \"myapp\",\n          \"component\": \"jobscheduler\"\n        }\n      }\n    }\n  ]\n}\n"

----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToJsonFile =
    {
      yamlContent,
      outputType ? "array",
    }:
    let
      jqReturnValue =
        if outputType == "array" then
          "."
        else if outputType == "object" then
          "{ items:. }"
        else
          throw "Unknown output type ${outputType}";

      jqCommand = "${pkgs.jq}/bin/jq -n '[inputs] | if length == 1 then .[0] else ${jqReturnValue} end | .'";
    in
    pkgs.stdenv.mkDerivation {
      name = "yaml2jsonfile";
      inherit yamlContent;
      passAsFile = [ "yamlContent" ];
      phases = [ "installPhase" ];
      installPhase = "${pkgs.yq-go}/bin/yq $yamlContentPath -p yaml -o json | ${jqCommand} > $out";
    };
}
----
====

'''

=== `yamlToMultiJsonFiles`
The purpose of this function is to automate the creation of a set of files compatible with the https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/addon-manager/README.md[Kubernetes AddonManager] which is the https://github.com/NixOS/nixpkgs/blob/046eee4ec50a7b86148b056d6ddb44c4fc9a6a15/nixos/modules/services/cluster/kubernetes/addon-manager.nix#L27[default way of installing addons if you're running Kubernetes bare metal on NixOS].

It turns some YAML content describing ONE OR MORE Kubernetes resources into as many JSON manifests as resources described. The return value is the [.underline]#*store path*# containing built files.


[source,haskell]
----
yamlToMultiJsonFiles :: Attrset{ yamlContent, yqExpression ? null } -> Derivation
----

yamlToMultiJsonFiles, by default, uses the following https://github.com/mikefarah/yq[yq] expression: +
`.metadata.name + "-" + (.kind | downcase) + "-" + (.metadata.namespace // (.kind | downcase))`

Files are created as follows:

* The *filename* is, by default, the string interpolation of resource name, resource kind and resource namespace. In case of a non-namespaced resource, the kind is repeated.
 * The *value* is the content of the file itself

The input is an Attrset of:

* *yamlContent*: YAML content as string
* *yqExpression*: yqExpression override in case you want a different naming.



.example
[%collapsible]
====
[source,nix]
----
builtins.attrNames (builtins.readDir ( yamlToMultiJsonFiles { yamlContent = builtins.readFile ./services.yml; } ))

[
  "myapp-jobscheduler-service-myapp.json"
  "myapp-service-myapp.json"
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToMultiJsonFiles =
    {
      yamlContent,
      yqExpression ? null,
    }:
    let
      yqExpr =
        if yqExpression == null then
          ".metadata.name + \"-\" + (.kind | downcase) + \"-\" + (.metadata.namespace // (.kind | downcase))"
        else
          yqExpression;
    in
    pkgs.stdenv.mkDerivation {
      name = "yaml2multijsonfile";
      inherit yamlContent;
      passAsFile = [ "yamlContent" ];
      phases = [ "buildPhase" ];
      buildPhase = ''
        mkdir $out
        cd $out
        ${pkgs.yq-go}/bin/yq -p yaml -o json -s '${yqExpr}' $yamlContentPath
      '';
    };
}
----
====

'''

=== `yamlToMultiJsonFilePaths`
It turns some YAML content describing ONE OR MORE Kubernetes resources into as many JSON manifests as resources described. The return value is a list of [.underline]#*store path*# containing built files.

It uses yamlToMultiJsonFiles under the hood, inputs and logic are the same.

[source,haskell]
----
yamlToMultiJsonFiles :: Attrset{ yamlContent, yqExpression ? null } -> [String]
----

.example
[%collapsible]
====
[source,nix]
----
yamlToMultiJsonFilePaths { yamlContent = builtins.readFile ./services.yml; }

[
  "/nix/store/7c6px9in1i05bl3r2j9jym564vhhpzs0-yaml2multijsonfile/myapp-jobscheduler-service-myapp.json"
  "/nix/store/7c6px9in1i05bl3r2j9jym564vhhpzs0-yaml2multijsonfile/myapp-service-myapp.json"
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToMultiJsonFilePaths =
    {
      yamlContent,
      yqExpression ? null,
    }@args:
    getGeneratedFiles (yamlToMultiJsonFiles {
      inherit yamlContent yqExpression;
    });

}
----
====

'''

=== `yamlToNix`
Loads parses YAML definitions into Nix language. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlToNix :: String -> Attrset / [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
yamlToNix (builtins.readFile ./server-cert.yml)

{
  apiVersion = "cert-manager.io/v1";
  kind = "Certificate";
  metadata = {
    name = "mypp-serverauth";
    namespace = "myapp";
  };
  spec = {
    dnsNames = [ "myapp.mydomain.com" ];
    issuerRef = {
      kind = "ClusterIssuer";
      name = "letsencrypt-dns";
    };
    secretName = "myapp-server-tls";
    usages = [ "server auth" ];
  };
}


yamlToNix (builtins.readFile ./services.yml)

[
  {
    apiVersion = "v1";
    kind = "Service";
    metadata = {
      labels = {
        app = "myapp";
        component = "main";
      };
      name = "myapp";
      namespace = "myapp";
    };
    spec = {
      ports = [
        {
          name = "http";
          port = 80;
          protocol = "TCP";
          targetPort = "http";
        }
        {
          name = "https";
          port = 443;
          protocol = "TCP";
          targetPort = "https";
        }
      ];
      selector = {
        app = "myapp";
        components = "main";
      };
    };
  }
  {
    apiVersion = "v1";
    kind = "Service";
    metadata = {
      labels = {
        app = "myapp";
        component = "jobscheduler";
      };
      name = "myapp-jobscheduler";
      namespace = "myapp";
    };
    spec = {
      ports = [
        {
          name = "http";
          port = 3000;
          protocol = "TCP";
          targetPort = "http";
        }
      ];
      selector = {
        app = "myapp";
        component = "jobscheduler";
      };
    };
  }
]
----
====


.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToNix =
    yamlContent:
    fromJSON (yamlToJson {
      inherit yamlContent;
    });
}
----
====

'''

=== `yamlToNixList`
Same as yamlToNix but forces the output to be a List. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlToNix :: String -> [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
yamlToNixList (builtins.readFile ./server-cert.yml)

[
  {
    apiVersion = "cert-manager.io/v1";
    kind = "Certificate";
    metadata = {
      name = "mypp-serverauth";
      namespace = "myapp";
    };
    spec = {
      dnsNames = [ "myapp.mydomain.com" ];
      issuerRef = {
        kind = "ClusterIssuer";
        name = "letsencrypt-dns";
      };
      secretName = "myapp-server-tls";
      usages = [ "server auth" ];
    };
  }
]
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlToNixList =
    yamlContent:
    let
      fileAbsPaths = yamlToMultiJsonFilePaths { inherit yamlContent; };
    in
    map (path: readPathAndThen path fromJSON) fileAbsPaths;
}
----
====

'''

=== `nixToYaml`
Converts Nix code to YAML string.  It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
nixToYaml :: Attrset -> String
----

.example
[%collapsible]
====
[source,nix]
----
builtins.readFile (nixToYaml { a = 1; b = 2; c = 3; })
"a: 1\nb: 2\nc: 3\n"

builtins.readFile (nixToYaml [{ a = 1;} { b = 2;} {c = 3;}])
"- a: 1\n- b: 2\n- c: 3\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  nixToYaml =
    attrs:
    let
      jsonContent = toJSON attrs;
    in
    pkgs.stdenv.mkDerivation {
      inherit jsonContent;
      name = "nixtoYaml";
      passAsFile = [ "jsonContent" ];
      phases = [ "buildPhase" ];
      buildPhase = "${pkgs.yq-go}/bin/yq -p json -o yaml $jsonContentPath > $out";
    };
}
----
====

'''

=== `jsonToYaml`
Converts JSON content to YAML. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
jsonToYaml :: Attrset { jsonContent, topLevelKey ? null } -> String
----

The input is an Attrset of:

* *jsonContent*: JSON string data.
* *topLevelKey*: by default a JSON array is converted to a bare YAML array. This allows you to turn it into an object specifying the key the array should be put under. It's *ineffective if the content is not a list*.

.example
[%collapsible]
====
[source,nix]
----
jsonToYaml { jsonContent = builtins.readFile ./services.json; topLevelKey = "services"; }

"services:\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp\n      namespace: myapp\n      labels:\n        app: myapp\n        component: main\n    spec:\n      ports:\n        - name: http\n          port: 80\n          protocol: TCP\n          targetPort: http\n        - name: https\n          port: 443\n          protocol: TCP\n          targetPort: https\n      selector:\n        app: myapp\n        components: main\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp-jobscheduler\n      namespace: myapp\n      labels:\n        app: myapp\n        component: jobscheduler\n    spec:\n      ports:\n        - name: http\n          port: 3000\n          protocol: TCP\n          targetPort: http\n      selector:\n        app: myapp\n        component: jobscheduler\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  jsonToYaml =
    {
      jsonContent,
      topLevelKey ? null
    }@args:
    readFile ( kallPackage args jsonToYamlFile { } );
}
----
====

'''

=== `jsonToYamlFile`
Same as jsonToYaml but stores the YAML content in a file.  It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
jsonToYamlFile :: Attrset { jsonContent, topLevelKey ? null } -> Derivation
----

.example
[%collapsible]
====
[source,nix]
----
builtins.readFile (jsonToYamlFile { jsonContent = builtins.readFile ./server-cert.json; topLevelKey = "services";})
"apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: mypp-serverauth\n  namespace: myapp\nspec:\n  issuerRef:\n    kind: ClusterIssuer\n    name: letsencrypt-dns\n  secretName: myapp-server-tls\n  usages:\n    - server auth\n  dnsNames:\n    - myapp.mydomain.com\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  jsonToYamlFile =
    {
      jsonContent,
      topLevelKey ? null,
    }:
    pkgs.stdenv.mkDerivation rec {
      name = "json2yaml";
      inherit jsonContent topLevelKey;
      passAsFile = [ "jsonContent" ];
      phases = [ "installPhase" ];
      yqTransform = if topLevelKey != null && jsonIsList jsonContent then "--expression '{ \"${topLevelKey}\":. }'" else "";
      installPhase = "${pkgs.yq-go}/bin/yq $jsonContentPath -p json -o yaml ${yqTransform} > $out";
    };
}
----
====

'''

=== `jsonFileToYamlFile`
Same as jsonToYamlFile but automatically reads from a path. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
jsonFileToYamlFile :: Attrset { path, topLevelKey ? null } -> Derivation
----

.example
[%collapsible]
====
[source,nix]
----
builtins.readFile (jsonFileToYamlFile { path = ./services.json; topLevelKey = "services"; })
"services:\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp\n      namespace: myapp\n      labels:\n        app: myapp\n        component: main\n    spec:\n      ports:\n        - name: http\n          port: 80\n          protocol: TCP\n          targetPort: http\n        - name: https\n          port: 443\n          protocol: TCP\n          targetPort: https\n      selector:\n        app: myapp\n        components: main\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: myapp-jobscheduler\n      namespace: myapp\n      labels:\n        app: myapp\n        component: jobscheduler\n    spec:\n      ports:\n        - name: http\n          port: 3000\n          protocol: TCP\n          targetPort: http\n      selector:\n        app: myapp\n        component: jobscheduler\n"
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  jsonFileToYamlFile =
    { path, topLevelKey ? null }@args:
    kallPackage args jsonToYamlFile { jsonContent = builtins.readFile path; };
}
----
====

'''


=== `yamlFileToMultiJsonFiles`
Same as yamlToMultiJsonFiles but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToMultiJsonFiles :: Attrset { path, yqExpression ? null } -> Derivation
----

.example
[%collapsible]
====
[source,nix]
----
builtins.attrNames (builtins.readDir (klib.yamlFileToMultiJsonFiles { path = ./services.yml; }))
[
  "myapp-jobscheduler-service-myapp.json"
  "myapp-service-myapp.json"
]
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToMultiJsonFiles =
    {
      path,
      yqExpression ? null,
    }@args:
    callWithYamlContent args yamlToMultiJsonFiles;
}
----
====

'''

=== `yamlFileToNix`
Same as yamlToNix but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToNix :: p -> Attrset / [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
yamlFileToNix ./services.yml
[
  {
    apiVersion = "v1";
    kind = "Service";
    metadata = {
      labels = {
        app = "myapp";
        component = "main";
      };
      name = "myapp";
      namespace = "myapp";
    };
    spec = {
      ports = [
        {
          name = "http";
          port = 80;
          protocol = "TCP";
          targetPort = "http";
        }
        {
          name = "https";
          port = 443;
          protocol = "TCP";
          targetPort = "https";
        }
      ];
      selector = {
        app = "myapp";
        components = "main";
      };
    };
  }
  {
    apiVersion = "v1";
    kind = "Service";
    metadata = {
      labels = {
        app = "myapp";
        component = "jobscheduler";
      };
      name = "myapp-jobscheduler";
      namespace = "myapp";
    };
    spec = {
      ports = [
        {
          name = "http";
          port = 3000;
          protocol = "TCP";
          targetPort = "http";
        }
      ];
      selector = {
        app = "myapp";
        component = "jobscheduler";
      };
    };
  }
]
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToNix = path: readPathAndThen path yamlToNix;
}
----
====

'''

=== `yamlFileToNixList`
Same as yamToNixList but with a path as an input, reading the file is handled internally. It does store data in the [.underline]#*nix store*#.

[source,haskell]
----
yamlFileToNix :: p -> [Attrset]
----

.example
[%collapsible]
====
[source,nix]
----
yamlFileToNixList ./server-cert.yml     # Only contains one cert-manager.io/v1/Certificate
[
  {
    apiVersion = "cert-manager.io/v1";
    kind = "Certificate";
    metadata = {
      name = "mypp-serverauth";
      namespace = "myapp";
    };
    spec = {
      dnsNames = [ "myapp.mydomain.com" ];
      issuerRef = {
        kind = "ClusterIssuer";
        name = "letsencrypt-dns";
      };
      secretName = "myapp-server-tls";
      usages = [ "server auth" ];
    };
  }
]
----
====

.implementation
[%collapsible]
====
[source,nix]
----
{
  yamlFileToNixList = path: readPathAndThen path yamlToNixList;
}
----
====
